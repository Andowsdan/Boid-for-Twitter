package com.handlerexploit.prime;

import com.handlerexploit.prime.ImageManager.Request;
import com.handlerexploit.prime.ImageManager.ExtendedRequest;
import com.teamboid.twitter.utilities.BoidActivity;

import android.app.Activity;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Handler;
import android.util.AttributeSet;
import android.view.View;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;

/**
 * <h3>Usage Example</h3>
 * 
 * <pre>
 * String imageURL = &quot;http://example.com/image.png&quot;;
 * RemoteImageView remoteImageView = (RemoteImageView) findViewById(R.id.icon);
 * remoteImageView.setImageURL(imageURL);</pre>
 * 
 * <div class="special reference"> <b>Development Notes:</b></br> This class is
 * thread safe and will work fluidly with the ViewHolder optimization pattern.
 * An example can be found <a href=
 * "https://github.com/DHuckaby/Prime/blob/master/examples/src/com/handlerexploit/prime/example/adapters/LazyImageAdapter.java"
 * >here</a>.</div>
 * 
 * <br/><br/>
 * See https://github.com/DHuckaby/Prime
 * 
 * Modified by kennydude to be very simplistic and fast and effecient :)
 * @author kennydude
 * 
 * @author Daniel Huckaby
 */
public class RemoteImageView extends View {

    private ImageManager mImageManager;
    public BoidActivity.OnAction onImageFinished = new BoidActivity.NullOnAction();

    private String mImageURL;

    public RemoteImageView(Context context) {
        super(context);
        setup(context, null, 0);
    }

    public RemoteImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
        setup(context, attrs, 0);
    }

    public RemoteImageView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        setup(context, attrs, defStyle);
    }

    private void setup(Context context, AttributeSet attrs, int defStyle) {
        mImageManager = ImageManager.getInstance(context);
        this.setDrawingCacheEnabled(true);
        
        p = new Paint();
        p.setAntiAlias(true);
        p.setDither(true);
        p.setFilterBitmap(true);
        p.setHinting(Paint.HINTING_ON);
        
        dst = new Rect(0,0,0,0);
        
        handler = new Handler();
    }
    Handler handler;
    
    boolean urlIsVisible(String source){
    	Object t = getTag();
    	if(t == null) return false;
    	return t.equals(source);
    }

    /**
     * Sets the content of this ImageView to the specified URL.
     * 
     * @param source
     *            The URL of a remote image
     */
    public void setImageURL(String source) {
        if (source != null && !urlIsVisible(source)) {
        	mBitmap = null;
            mImageURL = source;
            requested = false;
            handler.post(new Runnable(){

				@Override
				public void run() {
					mImageManager.get(mRequest);
				}
    			
    		});
        }
    }
    
    // Only request when user sees view
    boolean requested = false;
    Paint p;
    Rect src, dst;
    
    @Override
    protected void onDraw (Canvas canvas){
    	if(mBitmap != null){
    		dst.right = canvas.getWidth();
    		dst.bottom = canvas.getHeight();
    		
    		canvas.drawBitmap(mBitmap, src, 
    				dst, p);
    		//canvas.drawBitmap(mBitmap, 0, 0, p);
    	} else if(mDrawable != null){
    		mDrawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
    		mDrawable.draw(canvas);
    	}
    }
    
    public void setScaleType(ScaleType s){
    	mScaleType = s;
    }
    
    void askToRefresh(){
    	handler.post(new Runnable(){
    		@Override
    		public void run(){
    			invalidate();
    		}
    	});
    }
    
    public void setImageDrawable(Drawable d){
    	mDrawable = d;
    	askToRefresh();
    }
    
    public void setImageResource(int rs){
    	mDrawable = this.getContext().getResources().getDrawable(rs);
    	askToRefresh();
    }
    
    public void setImageBitmap(Bitmap b){
    	mBitmap = b;
    	askToRefresh();
    }
    
    Bitmap mBitmap;
    Drawable mDrawable;
    ScaleType mScaleType = ScaleType.CENTER_CROP;

    private ExtendedRequest mRequest = new ExtendedRequest() {

        @Override
        public void onImageReceived(final String source, final Bitmap bitmap) {
			if (mImageURL != null && mImageURL.equals(source) && bitmap != null) {
				handler.post(new Runnable(){
			
					@Override
					public void run() {
						mBitmap = bitmap;
						setTag(source);
			            src = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());
			            onImageFinished.done();
			            invalidate();
					}
					
				});
			}
        }
        
        @Override
        public String getSource() {
            return mImageURL;
        }

		@Override
		public Bitmap onPreProcess(Bitmap raw) {
			return raw;
		}

		@Override
		public int getHeight() {
			return RemoteImageView.this.getHeight();
		}

		@Override
		public int getWidth() {
			return RemoteImageView.this.getWidth ();
		}

		@Override
		public ScaleType getScaleType() {
			return mScaleType;
		}
    };
}